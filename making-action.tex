\startchapter{Making Socio Technical Congruence Actionable}
\label{chap:actionable}
This Chapter concludes the work of this thesis by exploring the final research question \textbf{RQ 2.4:} \emph{Can recommendations be given in a timely manner?}
To explore this final question we first present how such a recommender system might look like to motivate its potential usefulness and continue with describing our study in a student course setting to answer our final research question.

\section{Recommender System: Chat To Succeed}
Most software projects have infrastructure in place that automatically builds the software system on a regular basis. 
If there are errors in this build, if automated regression tests fail, or if a developer finds a major flaw in a build this build is considered as a failed build.  
Research shows that communication structures can be used to predict the outcome of a build~\cite{wolf:icse:2009}.  
Certain patterns of communication among team members who contribute to the code can determine if a build fails or succeeds. 
We expand this idea by providing specific recommendations of who should chat together to ensure a successful build.

We showed in Chapter~\ref{} evidence that a build might fail due to a possibility that members of the software team coordinated poorly between the time the current build broke, and the last known successful build. 
One possible reason for this lack of coordination is that the team members who worked on interrelated components failed to inform each other about their changes. 
This brings us to the discussion of socio-technical congruence.

\subsection{Socio-technical Gaps}
Socio-technical congruence defines the match of technical and social dependencies among people, for example tasks (technical) and task related communication (social)~\cite{cataldo:cscw:2006}. 
It compares a technical network to a communication network and identifies gaps where a coordination need exists, but no communication fills the gap. 
We showed that gaps have a negative influence on the project~\cite{} as well as that there are specific gaps that correlate to build failure~\cite{}. 

\begin{figure}[t]
\centering
\includegraphics[width=0.9\columnwidth]{figures/bad-to-good}
\caption{Identifying failure inducing coordination gaps.}
\label{fig:multipleplanes}
\end{figure}

\subsection{Our Recommender System}
A recommender system based on socio-technical congruence gaps to prevent a failed build will identify which gaps are most likely to induce build failures. 
Figure~\ref{fig:multipleplanes} shows the social and technical networks for three builds. 
Developers are connected by working on the same artifact and by dependent artifacts. 
We see that the failed build exposes two socio-technical gaps. 
A first glance, this might lead to the conclusion that these gaps are related to build failures. 
Further examination of the two following successful builds suggests that only one gap is bad since the other gap exists in one of the successful builds as well. 
To generate our recommendations we connect people in two ways: (1) on the technical level and (2) at the social level. 

\begin{description}
\item[Technical Level.] 
We mine repositories such as tracking systems and code for technical connections. 
For example, two developers have a technical connection if they work on dependent components or related bug fixes.
\item[Social Level.]
Social level connections can be found by mining email, chat, or comments~\cite{cataldo:cscw:2006}. 
In particular we need to focus on the tasks that are represented by the mined technical connections. 
\end{description}

We could draw data from repository system by IBM called Jazz, which stores issue tracking, source code, and change sets in a single database. 
Jazz records associations between work items and change sets, as well as the results of integration builds. 
A build, therefore, includes the code contributions between the current integration build and the previous integration build. 
Thus, we can identify who has contributed to each integration build and who has coordinated about change sets that were included in a particular build.

We also draw data from open-source projects. 
In an open-source project that does not use Jazz, we can identify change sets from their source code repositories, and corresponding tracker items or development mailing list items based on commit logs. 
Prior to the data mining, the project's development system must be studied and understood in order to provide good recommendations.

\section{A Course on Globally Distributed Software Development}
To answer our final research question for this thesis \textbf{RQ 2.4:} \emph{Can recommendations be given in a timely manner?} we conduct a case study together with students taking a class in globally distributed software development.
The reasoning for choosing this student course as the basis for exploring our final research question has several reasons:
\begin{itemize}
\item Providing a project infrastructure that supports data collection.
\item The distribution of the course across countries ensures a minimum at electronically recordable and mineable communication data being generated.
\item A course setting allows for more control to ensure data quality.
\item A course setting enables better access to study participants.
\end{itemize}

One key to explore our research question is to collect data to analyze.
In a course project we are able to choose and instrument the infrastructure used by the students to actively develop software and thus possible gain more insight or at least miss less data than in most industrial settings that rarely focus on collecting data for analysis.
This especially allows us to establish traceability links between artifacts that are often missing and need to be inferred using semi-accurate heuristics.

Furthermore, the distributed nature of the project makes synchronous non-text based communication more difficult and thus increasing the use of text based asynchronous, and therefore recorded, communication.
This additional need to rely and flexible and stable communication media, mainly email and text based chats, enables us to collect more data that is easier to mine than it would have been realistic in a collocated setting.
The distributed nature of the teams, also induced an openness to work in a more distributed fashion even among collocated team members due to a sensibilisation of trying to enable their remote team members to follow their discussions.

Due to the nature of the study being conducted in a course setting, we had more control about how participants are using technology and could give guidance on how to improve their collaboration through means that are easy to record.
Because participants need to attend lectures we can educate them in a way that emphasizes the importance of recording traceability links in an searchable format.

Since the participants are students taking a class on software development, we can more easily arrange for time to give feedback on the study in the form of the quality of data that we are collecting and the collections method influence on the development process.
This feedback loop enables us to change the data collection to accommodate the needs of the students more easily and therefore ensure data quality by mitigating the risk of participants neglecting the data collection process. 

In the next section we provide a more in-depth description of the study setting and the data that we expect to collect.

\section{Setting}
\subsection{Course Details}
The globally distributed software evelopment course taught at both the Universiyt of Victoria, Canada, and Altoo University, Finland, aims at teaching students how to develop software in a distributed setting.
In this particular course student teams where forced to deal with the issues that come with a distributed team in an extreme way since both West Coast Canada and Finland are seperated by a time difference of 11 hourse minimizing the time all team members are awake.
This both necessaitates and motivates the students to apply lessons learned in the class room as for most of the students this situation is unfamiliar.

The course on globally distributed software development took place starting in October 2011 and ended in April 2012.
With the Finnish stutends starting in October 2011 and the Canadian students joining the development effort in Januaray 2012.
This further allowed the students to engage in remote collboration as the Finish students represent the experts on the system the teams are working on and will need to guide their Canadian teammates in getting used to the projects layout and functions.

Besides developing a software product the Canadian students also have regular classes.
During a regular class the students participate in a seminar style setting that requires each student to read a set of papers, that can be discussed on the course blog, and discuss implications of the findings detailed in the papers and how these findings may apply to their current development experience.
Every two weeks the seminar style class is interrupted for a project wide meeting to bring together all the teams, including the Finish team members, to show case their progress and to plan the next steps and for the following two weeks.

The students filled out a survey every other week giving feedback on the class, the development process, and the use of different tools for communication and development.
Besides this bi-weeklu survey the students also had the chance to talk to the course instructors as well as the teaching assitant to issue concerns and make suggestion on how to improve the course for the students as well as issues they see with the quality of the collected or non-collected data.

\subsection{Team Composition}
As desribed earlier each development team consists of both students from Canada and Finnland.
There are three teams with each team consiting of four students from Canada and two students from Finnland.

In addition to the three teams we also have a product owner of software product that came up with the idea of the product, that we will describe in greated detail in Subsection~\ref{}.
The product owner is located in Finland and is responsible for prioritizing the different features that he wants to be implemented.
Moreover, he negotiates with the teams what items they should aim for within a given two week span. 

To coordinate the work across teams, one Finish student has become the scrum master or defactor project manager.
He is both the most experienced developer as well as has the most knowledge about the projectas he is using the product within his own company.
Facilitating coordination across teams entails setting up meeting between team memebrs as well as structuing the bi-weekly project meeting.
He also takes care of scoping out development tools to use and ensures that everyone is up to speed with issues arising from other teams that may implicate their work.

\subsection{Development Project}
The students in this course are extending the agile-planning tool agilefant\footnote{}.
Agilefant combines task creation, management, and planning into one tool that allows both to schedule different tasks for different sprints, with a sprint being a time period that is meant to implement a fixed set of tasks.
Furthermore, tasks can be organized hirachacly and be of different types, such as user stories or bug reports.
 
As mentioned previously, this product was conceived by the product owner and has since been developed by students participating in cap-stone projects~\footnote{} at Altoo University, Finnland.
The tool itself is open source and available to any one to download, install and extend as they see fit.

Besides being a student driven project it found a number of users in industry.
Due to the development being mainly undertaken in the cap-stone projects that are offered yearly to the students, the project progresses in spurts instead of gradually.
Nevertheless, the stability of its core feature and light weight apporach it is popular among small and mid-sized companies to plan their development.

\subsection{Development Process}
The project follows a scrum process~\cite{} and thus development progresses in small sprints working of a common backlog.
A sprint, in the case of our project, is defined to be two weeks long starting with a planning session and ending in a retrospective.
The planning sessions and retrospectives take place between two sprints at the same day starting with the retrospective followed by the planning for the next sprint.

\subsection{IT-Infrastructure}
The source code is managed using GIT\footnote{} and is available on github.com\footnote{}.
Although agilefant or github.com issues can be used for task management both are missing important features, github.com is missing the planning capabilities of a full agile planning tool and agilefant is missing the ability to discuss work items.
Therefore, we use IBM Rational Team Concert for the planning of sprints and tracking of work items.
An additional advantage of IBM Rational Team Concert it is intergrating with Eclipse the main development environment, which also integrates with git. 

Besides using discussions on work items, the students also use email and irc for communication.
To ensure that everyone has the same knowledge students are encouraged to summarize their email and irc discussion in work item discussion.
For group meetings especially the planning and retrospective session we provided the student with seperate rooms and internet access to use google hangout for video chatting and screen sharing when disucssing their group individual sprint plans.
For the project meeting after each sprint to demo their accomplishment to the development team at large, we provided conferences room with multiple microphones and screens to simultaniously show a number of remote participants as well as screen sharing sessions. 

To further support the development process the students set up a Jenkins an open source webbased build system.
This build system allows for continous testing and thus help the students to get a better understanding of their progress with respect to implementing their tasks for a given sprint.

\section{Background and Related Work}

\section{Methodology}
\subsection{Proximity to Infer Real Time Technical Networks}
In order to be able to explore the possibility of recommending improvements with respect to the socio-technical networks, we need to be able to intervene before the majority of work has been done.
The main issue with creating real time socio-technical networks lies with constructing technical networks as they are only known once a developer submits her changes to a repository.
On the other hand social-networks can be more readily constructed in real time because in order to communicate, at least electronically, will yield a trace for each bit of communication traveling from one person to the other and thus allow to extend a social network with each new instance of communication.

To gain a similarly effective way to construct technical network we build upon the work of Blincoe et al~\cite{}, who proposed a measure called proximity using Mylyn~\cite{} traces to infer real time developer dependencies.
Mylyn is an Eclipse plug-in that records edits and selects within source code fiiles.
These event show which artifacts have been modified and selected thus allow the partial construction of a technical network based on ownership information of the modified, selected, and implicated source code artifacts.

In order to record this information in real time in a central repository we developed a plug-in that is captureing events recorded by Mylyn, connecting them to the current task a developer is working on, and submitting this information to a central server. 
To encourage students fruther to install this plug-in, we also provided a visualisation of the current proximity of a developer to any other developer given her current task in a visualization plug-in called ProxiScentia~\cite{}.

\subsection{Data Collection}
For our study we collect six types of data:
\begin{itemize}
\item Communication data such as e-mails, irc chat logs and work item dicussions.
\item The source code repositories on github.com, including each developers fork of the main repository.
\item Log of the build engine indicating failed and successful builds.
\item Documentation and diaries created by students during the course.
\item Surveys and questionnaires completed by students throughout the course. 
\item Mylyn events gathered using our custom build Eclipse plug-in.
\end{itemize}

Although we are not necessarily intrested in constructing social networks for this part of the study but rather we are concerend whether it is possible to prevent build failures given a certain set of collectible data, we need access to as much comminication data as possible not only as a means to see what kind of problems arose and whether they were of any importance to the developers.
For example, are build failures a problem for the developers and as such are all build failure equal.
Knowing which build failure are actually problematic to the developers lets us focus on those instances that do matter.

To further the investigation into the issues reported by the developers we make use of the version control systems used.
In our case these are several git repositories hosted on github.com.
Each developer owns her own forked repository from which she pushes changes to her respective team repository.
Once a feature implementation or bug fix has been reviewd by the product owner it is pushed to the project repository to ensure that each development team and team members is working on the latest stable code.

Since implementing quality features was a main concern during the class, the students set up a buildengine to continously test their implementations.
Jenkins\footnote{}, the build engine used by the teams, keeps a log of all the builds as well as their outcomes.

Besides collecting data that is generated by the development activities of the students during the course we also asked them to keep a development direy as well as fill out frequent surveys that gauge their impression of the progress within the project as well as the adequacy of the tools used.

Finally, as mentioned in the previous Subsection~\ref{} we also collect the code itneractions with respect to which methods in the source code have been edited or selected in a central repository.

\subsection{Analaysis}
Our analysis of for determine the feasibility of creating predictions based on socio-technical networks.
We go over data collected during the course in six steps, starting from identifying issues of interested to showing how recommendations based on our framework could have avoided these build failures:

\begin{enumerate}
\item Identify build issues mentioned by the developers.
\item Identify the actual failed build in the Jenkins build logs.
\item Identify the code changes that contributed to the build failure.
\item Check if the recorded code interactions could have predicted the build failure.
\item Check if the relation between the code changes could have predicted the build failure.
\item Check if using the social-network help findings the right people to include in order to resolve the issue.
\end{enumerate}

\paragrpah{Identifying build issues.}
To find build issues that are truely build issues to the developer and not only such that report as a build failure due to test cases that failed and were meant to fail, we code the communication with respect to problems experienced in the project.
From those coded problems we select all problems related to building the software.

\paragraph{Indetifying the actual failed build.}
After we identified from all the recorded communication what failed builds are truely failures, we identify those builds as they are shown in the Jenkins logs.
These builds show what went wrong as well as what changes are new to those builds that potentially broke it.

\paragraph{Identify code changes.}
Knowing the code changes that newly went into a build and consequently made it fale, are important to now as we need to use those change-sets to determine which interaction history to investigate.
From the change set we can determine the task worked on, as we require every student to annotate each submitted change-set with work item id the change-set was meant to implement.

\paragraph{Check code interactions}
Having the change-sets and thus the work items the developers worked on, enables us to retrieve the specific code interactions associated with that tasked produced by the developer that submitted the possibly offending change-set.

\paragraph{Check change relations.}
Knowing both, the change-set as well as the interaction traces that where involved in the failed build, we can contrast and overlay those change-sets as well as code interactions to see if the path of different developers overlap in way that let's us predict the issues we observed.

\paragraph{Check social network}
In case we see observe that the code traces that we collected could have predicted the issue, we look for cues in the communication medio for the resultion of the issues and see if the knowledge about the code traces and the communication happening at the time of implementing the change-set.
Finding a relation between the code interactions and the ongoing communication during the implementation contrasted with the communication needed to resolve the issue create by the change-set is the key to building a useful recommendation.

Instead of analysing each build failure that is important to the developers, we focus on finding one build that let's us trace the error back to the code interactions as well as shows a connection between the code interactions and the communication needed to resolve the build issue.
We will leave the autmatzation and analysis for future work.

\section{Findings}
\begin{table}[tb]
\centering
\begin{tabular}{lll}
\toprule
something\\
\midrule
somthing\\
\bottomrule
\end{tabular}
\label{tab:}
\caption{Statistics about student problems and builds}
\end{table}

\subsection{Build Failures That Matter}
Throughout the feed back and comminication logs received from the students show that the most important problems to the students are those build failures that prevent other teams from continuing their work.
These issues usually happend towards the end of the sprint as this is the time the teams are integrating their code into a common code base.

QUOTE HERE

QUOTE HERE

On the other hand, most failed builds are of less interest to the students for two reasons: 
(1) test got outdated as the core functionality of the product changed considerably 
and (2) the product owner was deciding what features are of acceptable quality regardless of the test case results.

Since most of the work preformed by the students changed core functionality or at least needed to extend the core functionality that the implementation required substantial changes to the existing code changes that often broke the old test cases.
At the same time test cases lose in value with respect to deciding whether a feautre is of acceptable quality, because the product owner is deciding on whether a feature is deployable based on a demo and manual testing.

\subsection{Preventable Build Failures}
\begin{table}[ht]
\begin{tabular}{ccc}
\toprule
awesome\\
\midrule
thesis\\
\bottomrule
\end{tabular}
\label{tab:overlappingtraces}
\caption{Overlapping code interaction traces that lead to a merge conflict.}
\end{table}

Table~\ref{overlappingtraces} shows two traces that directly link to one of the major build failures caused by merge conflicts.
Similarly, the change-set that these two traces turn into show the issue resulting from merging.

EXPLAIN THE OVERLAP IN THE TRACES

Note that the time those traces were recoreded during the same sprint but shifted in time.
Furthermore, the owners of the two traces and thus change-sets belong to different teams whose work is supposed to be integrated towards the end of the sprint.

\subsection{The Right Recommendations}
We saw that most of the build failures that are of high relevance to the developers deal with issues arising from merging code from several teams.
Although when such a build failed communication among team members spikes, it is confined to the team that merges their code last and thus experiences the build failure once they merged their code.
Thus, the communication that is angoing in order to resolve the build issues does not necessarily include the people that could have helped to prevent the build from failing.

Nevertheless, the recordings and communication after the merge conflict had been resolved gives a better picture of the people involved.
After the issue had been resolved the team fixing the issue issued the concern in the following retrospective and sprint planing as well as contacted the respective team.
From the communication it became aparent that the issue could have been prevented if the authors of the conflicting change-set would have known about each others change.

\section{Discussion}
In this chapter we set out to answer the question whether it is pissible to make recommendations to prevent build failures before they happen.
We found that the methods proposed by Blincoe et al~\cite{} gathering real time code interactions using Mylyn to make the post-mortem analysis perfomed in the traditional socio-technical congurnce context~\cite{} actionable, is useful to provide real time recommendations.
Although we did not show by implementing a recommender system, nontheless, the data is in place and shows promise to resolve certain issues before they become problematic.
The students course showed that there is a link between the build failures that stems from technical dependencies that can be constructed while developers are working to implement their work items.

Although the study was conducted in a student course as opposed to an industrial setting, we used an existing open source project that is used in industry as project for the students to work on.
Together with the use of state of the art tooling and agile methodology as well as co-op suplemented programming experience of the students made this project very much alike a profesional defvelopment project.
Another threat to the validity of our study lies within the focus on finding a single isntance which could have been prevented to our recommendation framework.
Although this severly limits the generalizability, especially in the light of the build failures being due to merge conflicts, we think that as a proof of concept this one instance is sufficient and with a more detailed conceptualization of technical dependencies more intricate build failures can be prevented.
