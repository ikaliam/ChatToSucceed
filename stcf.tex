% !TEX root = thesis.tex
\startchapter{Socio-Technical Congruence and Failure}
\label{chap:stc-net2}
Knowing that social networks have an effect on build success opens the next question as to how or more precisely which parts of the social network should be changed to increase the likelihood for a build to succeed.
For this reason we turn to the concept of socio-technical congruence as it reveals postulates that developer should communicate once their work intersects.
Thus in this section we explore the effect of socio-technical networks on build success:

\begin{description}
  \item[RQ 1.2:] Does Socio-Technical Networks influence build success?
\end{description}

% the idea
Although socio-technical congruence has only been studies in connection with productivity intuitively there should be a conniption to software quality such as build success.
For example, imagine two developer modifying classes that share call and data dependencies and one developer making changes that violate certain assumptions the other developer relies on when using the modified code.
This might introduce an error that could have been prevented if both developer would have discussed their work.
Thus, we hypothesize that the concept of socio-technical congruence relates to software quality as well as productivity and might be used to point towards improvements in the social network by pointing out developers that should communicate.

In the remainder of this chapter, we start with detailing the back ground relevant to studying coordination, its influence, and how coordination needs are identified by other researchers(Section~\ref{}).
Next, we discuss how we calculate socio-technical congruence as well as highlight some modifications to explore to allow us to explore whether a difference in the magnitude of technical dependencies and amount of communication plays a role to possibly highlight improvements for social interactions among software developers (Section~\ref{}).
Subsequently, we briefly go over the methodology that is relevant to exploring our research question that were not mentioned in Chapter~\ref{} (Section~\ref{}).
Then, we go over the analysis and results we obtained in Section~\ref{} followed by a discussion of the results and their implications in Section~\ref{}.
We conclude this chapter with offering an answer to our research question and leading into the subsequent Chapter~\ref{} (Section~\ref{}).

%TODOS
% merge intro into background
% remove research objective section
% adjust methodology/remove stuff
% rewrite conclusion to answer the research question and lead into next chapter (approach)
%
% TAKE OUT WEIGHTS


%--------------------------------------------------------------------------------------------------------------
\section{Background}
\label{sec:background}
TODO new blurb here

Here we discuss coordination in software engineering and discuss socio-technical congruence as a way to measure coordination quality. We then present our case study of the IBM Rational Team Concert\textsuperscript{\textregistered} project.

\subsection{TODO Introduction}
Coordinating the efforts of individuals working together in a team is
necessary to build software systems. The complexity of current systems require contributions
from tens or hundreds of people who may span multiple offices, cities, or even continents.
To build such systems, we need to ensure that the team is not only capable of
developing components of a system, but also has the governance to be able to integrate the
interdependent parts into a whole.

We describe a case study of socio-technical coordination and its effect on software builds in the IBM\textsuperscript{\textregistered}
Rational Team Concert\textsuperscript{\textregistered} (RTC) software product\footnote{IBM, Rational, Jazz and Rational Team Concert are trademarks or registered trademarks of International Business Machines Corporation in the United States, other countries, or both.}.
Our approach to investigating coordination is to examine the
alignment between the technical dimension of work and the social relationships
between team members. This alignment is called \textbf{socio-technical
congruence}~\cite{cataldo:cscw:2006}. High socio-technical congruence
has been shown to be a predictor of coordination success
\cite{cataldo:cscw:2006,ehrlich2008:gaps}.
The mismatches between the social and technical dimensions, or \textbf{gaps},
also have been observed as increasing resolution times for software activities.
The objective of this study is to investigate the effects of socio-technical congruence on high-coordination software development activities during a project.
%, and to examine the usefulness of the measure when drawing conclusions about collaboration around software development.

We seek to discover the relationship that congruence has on the probability that a regularly-scheduled software build will be successful.marczak:re:2008
We conduct a case study of a large software project at IBM.  A build result, which can be \emph{error} or \emph{OK}, indicates the relative health of the project up to that build. To
measure socio-technical congruence we apply two different measures: a
previously-published congruence approach \cite{cataldo:cscw:2006},
and a weighted congruence approach that provides details about the size of a
gap between two individuals~\cite{kwan2009:weighted}. We
also examine RTC's processes and tools to identify any
explanations of the relationship between congruence and builds that
we find.

Our results indicate that congruence affects build success probabilities for certain types of builds.
In a continuous build, which may involve changes submitted primarily by a co-located team, high congruence leads to a higher probability of build success.
However, in an integration build, which involves code submitted by many distributed teams, high congruence actually reduces the probability of build success.
Although the congruence per build is relatively low at approximately 20\% overall, the team is able to coordinate to complete their builds.
We also find that the mean size of a congruence gap correlates inversely with build success probability.
Our findings on the socio-technical congruence and build quality in RTC are complemented by insights we
obtained by studying the context of the RTC project. Some of these results may be explained also by the congruence conceptualizations that we use in our empirical study.
% By using the weighted congruence measure we could investigate gaps in coordination at a fine level of detail and unveil interesting patterns in the teams' coordination behaviour.

Our case study adds to the scarce but needed empirical evidence about
socio-technical congruence measures in the investigation of coordination in
software projects, and allows us to
discuss improvements to congruence conceptualizations and measures. 

The paper begins with background on the need for coordination in software
projects and socio-technical congruence, and motivates the applicability of
socio-technical congruence to our case study setting in Section
\ref{sec:background}. We discuss related
work in Section \ref{sec:relwork} and describe the research objective in Section \ref{sec:objective}. We then describe
in Section \ref{sec:congruence} the two measurements for socio-technical
congruence that we used in our case study: an unweighted congruence measurement
found in the literature \cite{cataldo:cscw:2006}, and a weighted congruence measurement from
our own work \cite{kwan2009:weighted}. We describe our research questions and
methodology in Section \ref{sec:methodology}, and outline
the results in Section \ref{sec:results}. Our discussion 
in Section \ref{sec:discussion} provides an explanation of the effects we
observed. We conclude the paper by
outlining the threats to validity in our study in Section
\ref{sec:threats} and conclude in Section \ref{sec:conclusion}.

\subsection{The Need for Coordination}

Software is extremely complex because of the sheer number of dependencies~\cite{sawyer2004:teams}.
Large software projects have a large number of components that interoperate with one another.
The difficulty arises when changes must be made to the software, because a change in one component of the software often requires changes in dependent components~\cite{desouza:2008}. Because a single person's knowledge of a system is specialized as well as limited, that person often is unable to make the appropriate modifications in dependent components when a component is changed.

Coordination is defined as ``integrating or linking together different parts of an organization to accomplish a collective set of tasks''~\cite{vandeven1976}. In order to manage changes and maintain quality, developers must coordinate, and in software development, coordination is largely achieved by communicating with people who depend on the work that you do \cite{kraut:1995coordination}.

A successful software build can be viewed as the outcome of good coordination because the build requires the correct compilation of multiple, dependent files of source code.
A failed build, on the other hand, demotivates software developers \cite{holck2004,damian:icgse:2007} and destabilizes the product \cite{cusumano1997}.
While a failed build is not necessarily a disaster, it slows down work significantly while developers scramble to repair the issues.
A build result thus serves as an indicator of the health of the software project up until that point in time.

Thus, a developer should coordinate closely with individuals whose technical dependencies affect his work in order to effectively build software. This brings forth the idea of aligning the technical structure and the social interactions \cite{herbsleb2007:fose}, leading us to the foundation of socio-technical congruence.

\subsection{Coordination in Software Teams}
Research in software-engineering coordination has examined interactions among
software developers \cite{carter2004,marczak:re:2008}, how they acquire
knowledge \cite{ehrlich:icgse:2006,nakakoji2010:rdc}, and
how they cope with issues including geographical
separation~\cite{espinosa2007:team_knowledge,herbsleb2003:speed}.
The ability to coordinate has
been shown as an influential factor in customer satisfaction \cite{kraut:1995coordination} and  improves the capability to produce quality work~\cite{faraj2000}.


Software developers spend much of their time
communicating~\cite{perry94}. Because developers face
problems when integrating different components from heterogeneous environments~\cite{redmiles2007:continuous},
developers engage in direct or indirect
communication, either to coordinate their activities, or to acquire knowledge of
a particular aspect of the software ~\cite{nakakoji2010:rdc}.
Herbsleb, et al. examined the influence of coordination on integrating software
modules through interviews~\cite{herbsleb1999:architectures}, and found that
processes, as well as the willingness to communicate directly, helped teams
integrate software. De Souza, et al.~\cite{desouza2007:awarenessnetwork} found that implicit
communication is important to avoid collaboration breakdowns and delays. Ko, et al.~\cite{ko:icse:2007} found that developers were identified as the main source of knowledge about code issues.
Wolf, et al.~~\cite{wolf:icse:2009} used properties of social networks to predict the outcome of integrating the software parts within teams.
This prior work establishes the fact that developers communicate heavily about technical matters.

Coordinating software teams becomes more difficult as the distance between people increases \cite{herbsleb:icse:2001}.
Studies of Microsoft~\cite{bird2009:dds_quality,nagappan:icse:2008}
show that distance between people that work together on a
program determine the program's failure proneness.
Differences in time zones can affect the number of defects in software projects \cite{cataldo2009:quality}.

Although distance has been identified as a challenge, advances in collaborative
development environments are enabling people to overcome challenges of distance.
One study of early RTC development
shows that the task completion time is not as strongly affected by distance as in previous studies~\cite{Nguyen:2008Distance}. Technology that empowers distributed collaboration include topic recommendations~\cite{carter2004} and instant messaging~\cite{niinimaki2008}. Processes are adapting to the fast pace of software development: the Eclipse way~\cite{frost:ieeesoftware:2007} emphasizes placing milestones at fixed intervals and community involvement.


\subsection{Socio-technical Congruence}
Socio-technical congruence is defined as the match between the coordination needs established by the technical domain and the actual coordination activities carried out by project members. Socio-technical congruence in software engineering was brought to attention by Cataldo, et al.~\cite{cataldo:cscw:2006}, though the concept has been explored in engineering \cite{browning2001} and management science \cite{henderson1990}. A \textbf{coordination need} indicates that two persons should be coordinating based on the technical dependencies on the project. A coordination need is determined by analysing the assignments of people to a technical entity such as a source code module, and the technical dependencies among the technical entities.
Socio-technical congruence states that if there is a coordination need between two people, these people should be coordinating.
For example, if two people work on different, but dependent components of the project, then those persons should be coordinating with each other.

If two individuals have a coordination need, but do not coordinate, then there is a \textbf{gap} between these two individuals. A gap suggests the existence of a coordination problem. One of the goals of socio-technical congruence is to minimize the number of gaps, either by maintaining good coordination between individuals who have a coordination need, or by reducing the number of technical dependencies in the project and therefore reducing the coordination needs~\cite{sarma2008:measuring_stc}.

What socio-technical congruence offers is an approach to measure the coordination quality~\cite{cataldo:cscw:2006}. We can use this measurement to identify the effect of socio-technical coordination on software build quality.


%\section{Related Work}
%\label{sec:relwork}
%
%Socio-technical congruence was proposed initially as a fine-grained measure of coordination that can be used to diagnose coordination problems in a software development team~\cite{cataldo:cscw:2006}.
%The original conceptualization of socio-technical congruence was in Conway's Law, which observed that
%product architecture reflects organizational structure~\cite{conway:datamination:1968}.
%
%Socio-technical congruence has been recognized as an important element of product
%design in the management sciences field~\cite{sosa2004:manage}. The socio-technical congruence community goes one step further
%and declares that not only does this alignment happen as a consequence of product
%architecture, but that it is in fact desired
%\cite{sarma2008:measuring_stc,valetto2007:value}. Unfortunately there are only a
%handful of empirical research results that discuss the effects of the
%socio-technical congruence approach on software teams.

% First, we review research on studies of coordination in software engineering, and then we review related work on socio-technical congruence.




\subsection{Effects of Socio-technical Congruence}



Current research suggests that attaining a high level of socio-technical congruence is beneficial to an organization.
Evidence shows that higher congruence leads to faster completion of modification requests~\cite{cataldo:cscw:2006}. 
The presence of gaps increases the number of code changes \cite{ehrlich2008:gaps}, and a lack of coordination connections across system and organizational boundaries have a negative effect on performance~\cite{sosa2004:manage}.

Socio-technical gaps have been found to be an issue not only because they lower
the congruence and thus lower productivity~\cite{cataldo:cscw:2006}, but because they are especially problematic in the context of distributed development~\cite{ehrlich2008:gaps}. Thus, researchers have proposed remedial actions when socio-technical congruence gaps are discovered~\cite{valetto2007:value}. 
Examples of actions include closing a gap by augmenting coordination and eliminating the gap by refactoring software.

% ~\cite{curtis1988}
The usefulness of socio-technical congruence depends on the conceptualizations of
the social and the technical dimensions. Communication is believed to help people coordinate. However, it is not the only way to describe the social dimension. 
For instance, Cataldo et al.~\cite{cataldo:cscw:2006} evaluated congruence in the context of software development using different representations of actual coordination, including geographical proximity, IRC communication, and issue-tracking comments; these factors correlate with the resolution time of modification requests. There are also variations in the way technical dependencies can be handled. Cataldo et al.~\cite{cataldo:esem:2008} used differing ways to measure architectural dependencies and found that the congruence values computed using a ``files changed together'' dependency are more reliable than call graph dependencies~\cite{deSouza2004:thwarts_collaboration}. Gokpinar, et al \cite{gokpinar2010} applied a congruence technique and discovered that a higher coordination deficit leads to a larger number of filed incident reports, implying reduced quality.

Socio-technical congruence has been explored outside of the software development field, particularly in engineering and management disciplines \cite{henderson1990,sosa2004:manage,gokpinar2010,sosa2008}. Sosa \cite{sosa2008} described a formal technique to compute socio-technical congruence and identified ``potentially unattended technical interactions'', which are technical dependencies in modules that are not monitored. Gokpinar \cite{gokpinar2010}, independently of our work, developed a weighted socio-technical congruence technique that he applies to the automotive industry.

%In summary, there is a need to coordinate effectively in software development across technical dependencies that may cross geographical boundaries, and socio-technical congruence is a useful mechanism for studying coordination.


\section{Calculating Congruence}
\label{sec:congruence}
We describe unweighted congruence as presented by Cataldo et al. \cite{cataldo:cscw:2006} in Section \ref{sec:stc}. Weighted congruence~\cite{kwan2009:weighted}, described in Section \ref{sec:measure} is a weighted congruence measure from our work that addresses limitations of unweighted congruence.

\subsection{Technical Entities and Social Relationships}

A \textbf{technical entity} is an entity in a project that can be worked on by a person. Examples of a technical entity include a source code file, a compiled binary, a requirement, a task, or a bug. Socio-technical congruence has focused on the source code file as the technical entity \cite{cataldo:cscw:2006, ehrlich2008:gaps}, although work has also examined socio-technical congruence using a requirement~\cite{damian2010:rdc,marczak2009:crossfunctional} or a task~\cite{wolf:ieee:2009} as the technical entity. The choice of technical entity depends on the context of the study.

At the core of socio-technical congruence is the concept of a technical dependency. A \textbf{technical dependency} is a type of dependency between two technical entities. Examples of technical dependencies are in Box \ref{ph:technicalunits}.

\begin{placeholder}[t]
\begin{itemize}
\item Requirements that depend on each other~\cite{marczak:re:2008,marczak2009:crossfunctional}
\item Source code modules changed together in a change set~\cite{cataldo:cscw:2006,cataldo:esem:2008}
\item Source code that has a call-graph dependency~\cite{deSouza2004:thwarts_collaboration}
\item Tasks that depend on other tasks \cite{wolf:ieee:2009}
\end{itemize}
\caption{Examples of technical dependencies}
\label{ph:technicalunits}
\end{placeholder}

A \textbf{coordination need} is a relationship that indicates that two people should be coordinating, based on the assignment of each person to a technical entity, and the technical dependencies between the entities.

Social relationships are identified through \textbf{actual coordination}, which indicates how people in the organization are actually coordinating. Note that, despite the nomenclature ``coordination'' used in previous work \cite{cataldo:cscw:2006}, the actual coordination matrix does not need to represent coordination at all, but merely a relationship of interest between two people in an organization. Generally, one would want to choose relationships that are of interest to the performance of the organization, hence favouring the selection of relationships such as ``communication''. Examples of actual coordination appear in Box \ref{ph:relationships}.




\subsection{Calculating Socio-Technical Congruence}
\label{sec:stc}

Given $m$ people, and $n$ technical entities to examine, the coordination needs are calculated as 

\[ CN = A \times D \times (A)^t \]

\noindent where $A$ is an $m \times n$ assignment matrix that indicates that a person is assigned to a technical entity of the project, and $D$ is a $n \times n$ technical dependency matrix that indicates that a technical entity is dependent on another technical entity~\cite{cataldo:cscw:2006}. The result is $CN$, an $m \times m$ coordination needs matrix that indicates who in the project should be coordinating with whom.

Once the coordination needs matrix is calculated, congruence is calculated by comparing this matrix to an actual coordination matrix. If an edge exists in the actual coordination matrix, and the same edge exists in the coordination needs matrix, then there is congruence on this edge. Given definitions

\[ \text{Diff}(CN, AC) = card\{ \text{diff}_{ij} | CN_{ij} > 0 \& AC_{ij} > 0 \} \]
\[|CN| = card \{ CN_{ij} > 0 \} \]

\noindent the socio-technical congruence index is calculated as~\cite{cataldo:esem:2008}

\[ \text{congruence} = \frac{\text{Diff}(CN, AC)}  {|CN|} \]

\noindent where $AC$ is an $m \times m$ matrix representing actual coordination. The resulting congruence value is a number between 0 and 1, where 0 indicates no congruence, and 1 indicates full congruence.

\begin{placeholder}[t]
\begin{itemize}
\item Communication---A communicates with B~\cite{cataldo:cscw:2006, ehrlich2008:gaps, cataldo:esem:2008,damian2007:collaboration}.
\item Location---A is in the same location as B~\cite{cataldo:cscw:2006, ehrlich2008:gaps}.
\item Team structure---A is in the same team as B~\cite{cataldo:cscw:2006}.
\end{itemize}
\caption{Examples of actual coordination}
\label{ph:relationships}
\end{placeholder}

\subsection{Limitations of the Unweighted Socio-technical Congruence Calculation}
 
Unfortunately, the unweighted congruence measure has a limitation because socio-technical congruence identifies if a coordination need is either satisfied, or not satisfied, with no values indicating relative strengths.

The missing strengths prevent the identification of gaps that may be large or high-priority gaps that require attention.  Previous research has shown that projects succeed despite the presence of gaps. Marczak, et al.~\cite{marczak:re:2008} identified a project that delivered requirements on time despite the existence of gaps. 
Ehrlich, et al.~\cite{ehrlich2008:gaps} suggest that having an individual act as an intermediary between two groups, known as a \emph{broker}, may be able to mitigate the effect of gaps.
Communication structures may compensate for a lack of congruence~\cite{hinds:cscw:2006}. Literature in areas such as management science supports the idea that gaps are not a liability, but simply a reality~\cite{deSouza2004:thwarts_collaboration,hossain:cscw:2006}.

As developers have multiple dependencies~\cite{desouza2007:awarenessnetwork,mockus2002:opensource}, one would presume that those pairs with more coordination needs would need to coordinate more. Current socio-technical congruence provides no way to identify which pairs have high coordination needs. Researchers have suggested that both social and technical dependencies should be weighted \cite{valetto:msr:2007,kwan2009:weighted}, 
but do not evaluate their proposed changes.

\subsection{A Weighted Congruence Measurement}
\label{sec:measure}

We present an extension to congruence based on prior work~\cite{kwan2009:weighted} that addresses the
limitation discussed in the previous section. The intention is that this improvement will
provide more information about coordination behaviour than the current congruence measure. 

\subsubsection{Weighted Coordination Needs}
\label{subsec:ourmeasure}

\begin{figure*}
  \centering
  \subfloat[The coordination needs]{
    \includegraphics[width=20px]{figures/whitespace}
	\includegraphics[width=0.38\columnwidth]{figures/coordRequirement}
	\includegraphics[width=20px]{figures/whitespace}
     \label{subfig:coordRequ}
  }
  \hspace{12pt}
  \subfloat[The actual coordination]{
    \includegraphics[width=20px]{figures/whitespace}
    \includegraphics[width=0.38\columnwidth]{figures/actualCoord}
    \includegraphics[width=20px]{figures/whitespace}
    \label{subfig:actualCoord}
  }
  \hspace{12pt}
  \subfloat[The coordination that is lacking]{
    \includegraphics[width=20px]{figures/whitespace}
    \includegraphics[width=0.38\columnwidth]{figures/coordLack}
    \includegraphics[width=20px]{figures/whitespace}
    \label{subfig:coordLack}
  }
	\caption{Comparing coordination needs with actual coordination to find lacking coordination}
	\label{fig:communication}
\end{figure*}

This measurement assigns a number between 0 and 1 to each entry in the task assignment, task-dependency, and actual coordination matrices.
The weighted assignment matrix is a $m\times n$ matrix where $m$ is the number of people and $n$ denotes the number of entities. 
Each entry in the matrix illustrates the strength of the connection between a person $i$ and an entity $j$. Such a connection may be the expertise person $i$ has with a task $j$, or the priority that person $i$ places on task $j$.

The weighted dependency matrix is an $n\times n$ matrix where $n$ denotes the number of entities.
Each entry in the matrix describes the strength of the relationship between two entities. The weighted dependency matrix may show the ratio of dependencies an entity has with another over the number of total dependencies that entity has on others. 
For example, an entity strongly coupled with another has a high entity dependency.

To calculate the coordination needs matrix, we use the same formula proposed by Cataldo, et al.~\cite{cataldo:cscw:2006}, using the weighted values in the task assignment $A'$ and task dependency $D'$ matrices.

\[ CN' = A' \times D' \times (A')^t \]

\noindent This calculation will yield the weighted coordination needs matrix $CN'$, an $m\times m$ people by people matrix (Figure \ref{subfig:coordRequ}).
The coordination needs matrix shows how strong the relations between people are supposed to be based on their technical work.

\subsubsection{Weighted Actual Coordination}

Weighted actual coordination is a relative value that indicates the strength of a relationship between two individuals (Figure \ref{subfig:actualCoord}). A social network such as a communication network can be weighed according to the amount of ongoing communication. For example, one such weighing scheme may work as follows:

\begin{enumerate}
\item For a communication network, identify the largest value of communication between two individuals.
\item Divide all other values by the largest, thus normalizing the communication.
\item The result is a number between 0 and 1, where 1 indicates the largest value of communication in the network, and 0 is no communication.
\end{enumerate}

Other relationships that may be used as actual coordination are the amount of distance between individuals and how frequently they meet with other members in their team.

\subsection{Identifying Gaps in Socio-Technical Congruence}
\label{sec:lack}
We complement our
weighted congruence measure with a technique to generate a \emph{lack-of-coordination matrix}. This matrix not only identifies the
gaps between a coordination needs matrix and an actual coordination matrix, but can also identify the size of these gaps (Figure \ref{subfig:coordLack}). This lack-of-coordination matrix can be used with both unweighted congruence and weighted congruence.

 \[ g_{ij}(CN'_{ij}, AC'_{ij}) = CN'_{ij} - AC'_{ij} \]

\noindent for $i=1,\dots,m$ and $j=1,\dots,m$. The value of $g_{ij}$ is the \textbf{gap size} between the pair $ij$. The lack-of-coordination matrix illustrates situations where the proportion of communication exceeds the expected proportion of coordination needs. If the value is positive, then there is not enough coordination to satisfy the information needs requested by the $CN'$ matrix, resulting in a \textbf{gap}. If a value is negative, then there was more coordination than requested through the $CN'$ matrix, resulting in \textbf{overload}.  Neither situation necessarily results in a problem, but we believe that investigating overload and lack of coordination has implications on software engineering coordination.

\subsection{Weighted Congruence Index}
To convert the lack-of-coordination matrix to a single socio-technical congruence measurement, we apply

\[ \text{congruence} = 1 - \frac{\displaystyle\sum^{m}_{i=1} \sum^{m}_{j=1} g_{ij}}{\displaystyle\sum^{m}_{i=1}\sum^{m}_{j=1}CN'_{ij}} \]
\noindent for each $i$ and each $j$, unless $i=j$. This value, which is usually between 0 and 1, is an overall level of the congruence in the current network. In theory, the formula allows the index to fall outside of this range for some edge cases, but we did not observe any such cases in practice.

\subsection{Benefits of Weighted Congruence}
\label{sec:benefit}

Using a weighted congruence model allows us to deal with situations that are not handled with unweighted congruence.
Using the weighted congruence approach allows a person diagnosing the organization to benefit from \emph{locality} and \emph{relationship strength}.

\textbf{Locality}
allows us to identify which area of a network has a gap.
The lack-of-coordination matrix identifies which pairs of individuals do not fulfill coordination needs.
Although the original model does give us some limited locality in the sense of identifying congruence gaps, it is far more coarse grained.

\textbf{Relationship strength}
indicates how strong the relationship between two developers is. Relationship strength allows us to identify pairs of people who have multiple coordination needs, and therefore who need to coordinate more often with each other. Using relationship strength allows us to investigate coordination in more detail because we can investigate pairs with strong dependencies---these people also tend to be key individuals in a team.

By allowing better locality and relationship strength, we believe that this weighted model provides an in-depth technique with which to study congruence.

\subsection{Comparison with Other Weighted Measures}
We know of three other methods for assigning a weight to relationships and gaps. Cataldo proposed a system using weights with integers \cite{cataldo:esem:2008}. Ehrlich, et al. \cite{ehrlich2008:gaps} used a method to rank communication into three levels of importance. Gokpinar \cite{gokpinar2010} independently proposed a weighted congruence measure.

\subsubsection{Integer Matrices}
Cataldo's method assigns integer weights as values in the task assignment and task dependency matrices, resulting in a weighted coordination needs matrix. However, his formula in Section \ref{sec:stc} considers that a single communication instance is sufficient for satisfying any amount of coordination. Our method provides information about overload and lack of coordination, and provides a more fine-grained representation through the the lack-of-coordination matrix.

\subsubsection{Levels of Communication}
Ehrlich's method aggregates multiple relationships between two individuals to determine a ``level of communication''.  The relationships are: when two individuals work together on a project; when two individuals communicate several times a month for any reason; and when two individuals work together on shared files. If one or more of these relationships are true, they are added to provide a number representing the level.

The level of communication does not provide a ranking of gap size because they presume that a gap either exists, or that it is covered with one of the three levels. This paper mentions ranking gaps by size, but the gap rank is the total number of gaps that exist between two developers over the entire project. Thus, this measurement does not actually weigh the conceptual lack-of-communication distance between two individuals for each gap.

\subsubsection{Coordination Deficit}
Gopkinar independently proposed a weighted congruence called ``coordination deficit'', which is equivalent to our gap size. It weighs the number of dependencies between components, and the number of communications between individuals. Like our method presented in prior work \cite{kwan2009:weighted}, they calculated the coordination deficit by normalizing the edges and subtracting the values between the equivalent of an actual coordination network and a coordination needs network. The fact that the authors used normalization and algebraic subtraction suggests that they are reasonable approaches to calculating gap size.



\section{Research Methodology}
\label{sec:methodology}
In this section, we revisit our research questions, present our socio-technical
conceptualizations in RTC, and outline our analysis techniques.

\subsection{Data Description and Collection}
\label{sec:data}
\begin{figure*}
  \setbox1=\hbox{\includegraphics{figures/cochangedfiles}}% The smaller image
  \setbox2=\hbox{\includegraphics{figures/buildworkitem}}% The larger image 
	
  \centering
  \subfloat[Relationship among Builds, Change Sets, Files, and Work Items]{
    \includegraphics[height=.25\textheight]{figures/buildworkitem}
    \label{fig:buildworkitem}
  }
%  \hspace{8pt}

  \subfloat[Constructing a Coordination Needs Instance]{
  	\raisebox{0.4\ht2-0.5\ht1}{\includegraphics[height=.25\textheight]{figures/cochangedfiles}} \hfill
    \label{fig:cochangedfiles}
  }
%  \hspace{8pt}

  \subfloat[Constructing an Actual Coordination Instance]{
	\includegraphics[height=.25\textheight]{figures/buildsn}
     \label{fig:buildsn}
  }
  \caption{Conceptualizing Socio-technical Congruence in IBM Rational Team Concert}
  \label{fig:constructing}
\end{figure*}

In collaboration with IBM, we acquired a copy of the RTC repository containing data over a one year period.
%between June 2007 and June 2008.
This period of time covers twelve ``milestones'', varying from 1 week to 4 weeks long, during which the RTC team achieved a number of objectives. The end of our data set coincides with a major milestone in which RTC was to be released for open beta testing. 

In addition to quantitative data, we had obtained contextual information about the development team. We also investigated work items, comments, and reports available on the \texttt{jazz.net} web site.

The repository contains build information, work items, comments, change sets, and anonymised author information. We describe the data in more detail below.

\textbf{Work item.} A work item is a description of a unit of work to be done. A work item can be assigned a type of \emph{task}, \emph{enhancement}, or \emph{defect}.
We extracted 2008 unique work items that were relevant to our study.
The same work item may be involved in multiple builds; a total of 9218 non-unique work items were associated with a build across our data set. As our conceptualization focuses on the per-build level, we must consider these non-unique work items.

\textbf{Build.} A build is the process of compiling the software to create a working program.
A build outcome can be an \emph{error}, which indicates that there was either a
compilation error or a test suite error, \emph{OK}, which indicates no
errors, and \emph{Warning}, which indicates that there were warnings
returned by the compiler or the test suites.

A build contains the work from one or more work items, and these work items are not necessarily unique from build to build. The RTC repository does not keep a full record of every build over time, which means that we have more data points for the two most recent milestones compared to earlier in the project.

The RTC repository contains 533 builds, but we consider only builds that contain coordination needs, therefore dropping the number of builds to 214.  We remove 17 builds whose result is Warning because the way that the RTC team treats its Warning builds is dependent on the build. Finally, we remove 7 builds whose types could not be identified. The resulting data set contains 191 builds.

There are three types of builds that we investigate in this study: \emph{continuous builds}, \emph{nightly builds}, and \emph{integration builds}. Continuous builds, which are run regularly by a user, incorporate changes from the local development site, plus known stable components from remote sites.  Nightly builds also incorporate changes from the local site and stable components from remote sites approximately once a day. Integration builds integrate the latest components from every development site. The integration builds are often expected to break due to their large complexity, but errors in continuous and nightly builds are potentially indicative of coordination problems. Our data contains 122 continuous builds, 55 nightly builds, and 14 integration builds.

Because we have a data set of builds over time, we include the date of a build as a variable in our analysis. The build date is conceptualized as the number of days after the first build in our data set.

\textbf{Comment.} A comment is written text authored by a developer that is about a particular work item. Comments are the primary method of transferring information among developers in RTC. Multiple comments may be attached to a single work item. The data subset contains 9323 comments.

\textbf{Change set.} A change set is a collection of code changes to a number of files. When a developer updates the repository, all of the files that were changed together are updated in a single change set. A change set is generated by one author only, and is related to exactly one work item. A single work item may contain multiple change sets, and the same change set may occur in multiple builds. There are 3013 change sets in RTC. The number of change sets per work item ranges from 1 to 246. Ninety-five percent of the work items contain 15 or less change sets, and 42\% of the work items contain only one change set.

\textbf{Source code file.} A file contains source code and is included in change sets. Over time, a file may be associated with multiple change sets.

\textbf{Author.} An author is someone who has contributed to RTC. In our conceptualization, we specifically identify an author as meaning someone who has submitted a change set containing modifications to files. Because each change set can be attributed to one author, there are always at least as many change sets as there are authors in a build.


\subsubsection{Distribution of Build Data}
Each build involves a number of file authors, change sets, work items, and files. The same author, file, and work item may be involved across multiple builds.
We plot the histograms for each of these entities in Figures \ref{fig:hist_authors}, \ref{fig:hist_changesets}, \ref{fig:hist_workitems}, and \ref{fig:hist_files}.
Most of these distributions, especially the files, are skewed toward the left. 

\begin{figure*}[ht]
\centering

	\subfloat[Authors per Build] {
		\includegraphics[width=.45\columnwidth]{figures/hist_authors_per_build}
		\label{fig:hist_authors}
	}
	\subfloat[Change Sets Per Build] {
		\includegraphics[width=.45\columnwidth]{figures/hist_changesets_per_build}
		\label{fig:hist_changesets}
	}
	
	\subfloat[Work Items Per Build] {
		\includegraphics[width=.45\columnwidth]{figures/hist_workitems_per_build}
		\label{fig:hist_workitems}
	}	
	\subfloat[Files Per Build] {
		\includegraphics[width=.45\columnwidth]{figures/hist_files_per_build}
		\label{fig:hist_files}
	}
	\caption{Distribution of authors, change sets, work items, and files per build}
	\label{fig:entities_per_build}

\end{figure*}

\subsection{TODO Analysis Method}
\label{sec:analysis}
We use the unweighted congruence measure and weighted congruence measure presented in Section \ref{sec:congruence} for our analysis. We explain how we conceptualize congruence in this section.

\subsubsection{Conceptualizing Coordination Needs}
Previous studies use various heuristics for determining the dependencies between modules. One conceptualization is based on method call graphs generated by static code analysis, and has been used by Ehrlich \cite{ehrlich2008:gaps}.  Another conceptualization is a ``files-changed together'' heuristic, used by Cataldo \cite{cataldo:cscw:2006}, where the files that were modified in the solution of a change request are considered to be dependent on each other. A third conceptualization is to use experts who manually identify dependencies~\cite{gokpinar2010}.

We decided to construct dependencies based on a variation of the files-changed together heuristic because a ``files-changed together'' heuristic was more reflective of social relationships than a call-graph approach \cite{cataldo:esem:2008}, and best reflected our understanding of the RTC team's work.

We presume that a coordination need between two individuals exists if, minimally, these two individuals change the same file within the same build. In RTC, since only one author can be associated with each file check-in, there are two change sets involved, one associated with each file author. These two individuals should communicate with each other to ensure that the appropriate file dependencies are properly handled before the software is built (Figure \ref{fig:cochangedfiles}).

We generate the coordination needs matrix as follows.

\textbf{1) For each build, we identify every change set included in the build.} Every change set between the previous build and the current build is considered a part of the current build.

\textbf{2) We determine authorship for each file to generate the assignment matrix \emph{A}.} Since each change set has only one author, the author is assigned to every file in that change set. If an author modifies the same file in a different change set, then we add an additional edge for each change set in which the author changed that file.

\textbf{3) We determine the file dependencies in a build to generate the dependency matrix \emph{D}.} We iterate through every change set in the build. Each file is dependent on every other file within a change set. For example, if there are two change sets $C_1$ and $C_2$ in Build 1, with $C_1$ containing files A, B, and C, and $C_2$ containing files A, D, and E, the resulting dependency matrix $D$ would correspond to Figure \ref{fig:cochangedfiles}. In weighted congruence, we add one additional edge for each file pair that exists in each additional change set in that build. Thus, in a Build 2 with change sets $C_3$=\{A,~B,~C\} and $C_4$=\{A,~B\}, the dependency matrix entries in $D$ would be $D_{AB}= 2$, $D_{AC}=1$, and $D_{BC}=1$.

\textbf{4) We calculate the coordination needs as per the coordination needs calculation in Section \ref{sec:stc}.} The diagonals are ignored. When applying weighted congruence, we normalize the coordination needs matrix by taking the highest-ranked edge and dividing every entry in the matrix by that value. This converts each edge to a value between 0 and 1, indicating the relative rank of a coordination need between two individuals in the matrix.

We use this conceptualization because of the explicit relationships between change sets, builds, and authors in RTC. In previous ``files-changed-together'' approaches, multiple files checked in together were associated with multiple authors, whereas in RTC, a change set is authored by one author only. Our conceptualization of coordination needs represents a situation in which two individuals work on a file that are in two different change sets, but are within the same build. Though the file-level changes may not necessarily be to the same lines of code, we presume that multiple changes within a single file are sensitive enough such that each developer working on that file benefits by being informed of every change.

\subsubsection{Conceptualizing Actual Coordination}
We conceptualize actual coordination as communication through comments in the
RTC environment. We treat those who comment on a work item as a group of communicators, and assign weights when individuals comment on multiple work items that others also comment on (Figure \ref{fig:buildsn}).

Though the RTC commenting system allows users to post multiple posts to the same work item, we do not count multiple posts in a single work item as weighted communication.
Since a work item comment can be read by anyone with access to the work item repository, and there is no threading in the work item comments, we cannot assume that there is point-to-point communication from one person directly to another.
In addition, comment communication within the same work item do not correspond to weighted technical dependencies that cross different change sets.

We calculate the actual coordination matrix as follows.

\textbf{1) We identify the comments from the work items involved in a build.} Each build contains a number of change sets, and each change set has an associated work item with comments. For each work item, we include every comment that was posted after the previous build, but before the current build started.

\textbf{2) For each person who commented on a work item, we add a communication edge to every other person who commented on the same work item.} In weighted congruence, add one additional communication edge for each additional work item in which two individuals comment. We do not count weights for multiple comments in a single work item for the reasons discussed above. Thus, if work item $W_1$ contains commenters {A, B, C} and $W_2$ contains {B, C, D}, the resulting entries in the actual coordination matrix $AC$ would be $AC_{AB}=1$, $AC_{BC}=2$, $AC_{CD}=1$, $AC_{AC}=1$, and $AC_{CD}=1$.

\textbf{3) When applying weighted congruence, we normalize the communication network by taking the highest-ranked edge and dividing every edge in the network by that value.} This converts each edge to a value between 0 and 1, indicating the relative rank of comment-based communication between two individuals in the network.

This conceptualization of weighted communication represents the number of people who post a comment to the same work item.

We considered incorporating the RTC development mailing list into communication, but inspection of the mailing list revealed that the developers did not talk about technical issues and that the development list is primarily used for general announcements.

Unfortunately, due to the distribution of the 151 developers in the RTC team, as well as the one-year time period across which our study is conducted, we were unable to collect communication data such as instant messenger or face-to-face communication that we could associate to individual builds. Our concern with this missing data led us to inquire about the use of other forms of media among the team. We learned that although unofficial communication does happen between developers, the RTC team culture requires that the content of unrecorded and private communications be recreated as work item comments for consumption by remote project participants. We still expect that socio-technical congruence will be lower than we might expect from such a team as a consequence.

\subsubsection{Conceptualizing Gap Size}
The gap size in RTC represents a relative distance between the coordination needs and actual coordination. Since the two measurements are not necessarily comparable to each other, we normalize both measures to identify a relative ``rank'' of coordination needs and actual coordination. For example, if there is a coordination need in a build that has many dependencies, intuitively we would want a larger amount of communication around that build rather than on a build with few coordination needs. The gap size calculation identifies this mismatch.

We use the weighted congruence measure to compute the gap size. For each build, we calculate the gap size between each pair with a coordination need using the lack-of-coordination matrix explained in Section \ref{sec:lack}. Because of the normalization, each gap size is a value from $1$ to $-1$, where 1 is a large gap with little or no communication, 0 is full congruence, and -1 is a gap where there is more communication than necessary to fulfill the coordination need. We take the mean of these gap sizes and use this as a variable in a logistic regression model. We also consider an alternative calculation of gap size where we do not punish extra communication and set all values of gap size less than 0 to 0.

\subsubsection{Statistical Analysis Methods}
To answer Research Question 1, we conceptualize congruence as described in Section \ref{sec:analysis} and test our hypothesis using logistic regression.

Logistic regression is ideal to test the relationship between multiple variables and a binary outcome, which in our study is a build result being either ``OK'' or ``Error''. The presence of many data entities in this project means that we must consider confounding variables in addition to the socio-technical congruence when determining its effects on the probability of build success. Informally, logistic regression identifies the amount of ``influence'' that a variable has in the probability that a build will be successful.

We show the relationship between a variable and the build success probability by plotting the y-axis as the probability. We use probability because we feel that it is more intuitive than odds ratios or logistic functions. If there is a relationship between a variable and the probability of build success, then we should see that as the variable's value increases, the probability also increases. In the probability figures, the solid line is the expected value, and the dashed lines indicate the 95\% confidence intervals.

We run two different logistic regression models: one using weighted congruence, and one using unweighted congruence. We include the following variables: number of files per build, number of authors contributing to the build, number of files in the build, number of work items per build, the congruence, the build type, and the date of the build. We centre and scale each numeric variable.
Because we were concerned about possible interactions affecting our results, we included first-order interaction effects and used backward stepwise elimination to remove variables to keep AIC (Akaike's Information Criterion) low.

To answer Research Question 2, we calculate the gap size and include this as a variable in our logistic regression model to study the effects on build success probability.

We use R \cite{R} and the Design package \cite{designR} for logistic regression analysis.


\section{TODO Results}
\label{sec:results}
In the RTC repository, we analysed 191 builds; of these builds, 60 were error builds, and 131 were OK builds. Table \ref{tab:summary} displays summary statistics per build.
Figure \ref{fig:hist_unweighted_congruence} displays histograms for unweighted congruence, and Figure \ref{fig:hist_weighted_congruence} shows histograms for weighted congruence. The histograms compare the frequencies for each type of congruence for all builds, the OK builds, and the error builds only. There are some minor differences between unweighted and weighted congruence values; weighted congruence, for instance, largely reduces the number of ``fully'' congruent situations where congruence is 1.

The congruence values are low on average. The unweighted congruence has a mean value of 0.331, and the weighted measure has a mean value of 0.196, meaning that about one-third and one-fifth of the coordination needs are satisfied by actual coordination, respectively. Over 75\% of the builds have a weighted congruence value of less than 0.25.

\begin{figure}[t]
  \centering
  \subfloat[All builds]{
    \includegraphics[width=.3\columnwidth]{figures/hist_unweighted}
    \label{subfig:hist_nonweighted}
  }
    \subfloat[OK builds]{
    \includegraphics[width=.3\columnwidth]{figures/hist_unweighted_ok}
    \label{subfig:hist_nonweighted_ok}
  }
  \subfloat[Error builds]{
	\includegraphics[width=.3\columnwidth]{figures/hist_unweighted_err}
     \label{subfig:hist_weighted_err}
  }
	\caption{Distribution of Unweighted Congruence Values}
	\label{fig:hist_unweighted_congruence}
\end{figure}

\begin{figure}[t]
  \centering  
  \subfloat[All builds]{
	\includegraphics[width=.3\columnwidth]{figures/hist_weighted}
     \label{subfig:hist_weighted}
  }
  \subfloat[OK builds]{
    \includegraphics[width=.3\columnwidth]{figures/hist_weighted_ok}
    \label{subfig:hist_nonweighted_ok}
  }
  \subfloat[Error builds]{
	\includegraphics[width=.3\columnwidth]{figures/hist_weighted_err}
     \label{subfig:hist_weighted_err}
  }
	\caption{Distribution of Weighted Congruence Values}
	\label{fig:hist_weighted_congruence}
\end{figure}

\begin{table}[t]
\centering
\begin{tabular}{l|rrrr}
 & Min & Median & Max & Mean\\\hline
Authors & 2 & 17 & 44 & 18.62\\
Files & 5 & 131 & 3101 & 342.3 \\
Change Sets & 4  & 34  & 226 & 54.2\\
Work items & 4 & 34  & 182 & 48.3 \\
Build date range (days) & 0  & 345  & 361 & 319.2 \\
Unweighted cong. & 0  & 0.21  & 1 & 0.331 \\
Weighted cong. & 0 & 0.15  & 1 & 0.196\\
Gap size & -0.083 & 0.190 & 1.00 & 0.317 \\
\hline
\end{tabular}
\caption{Summary statistics}
\label{tab:summary}
\end{table}

\begin{table}[t]
\begin{center}
\begin{tabular}{l|rrrrrr}
 & 2. & 3. & 4. & 5. & 6. & 7. \\ 
  \hline
   1. Weighted & 0.77 & -0.22 & -0.14 & -0.12 & 0.05 & 0.02 \\ 
   2. Unweighted  &-- & -0.27 & -0.22 & -0.33 & 0.08 & 0.19 \\ 
   3. Authors &  & --& 0.41 & 0.76 & 0.10 & -0.30 \\ 
   4. Files &  &  & --& 0.37 & 0.08 & -0.20 \\ 
   5. Change sets &  &  &  &  --& 0.02 & -0.38 \\ 
   6. Work items  &  &  &  &  &  --& 0.04 \\ 
   7. Build date &  &  &  &  &  & -- \\ 
\hline

\end{tabular}
\end{center}
\caption{Pairwise Correlation of Variables per Build}
\label{tab:pairwise}
\end{table}

We calculated pairwise correlations between the variables weighted congruence, unweighted congruence, number of authors, number of files, number of change sets, number of work items, and build date (Table \ref{tab:pairwise}). There is a strong correlation between weighted and unweighted congruence, which is expected; a strong correlation between change sets and authors; and a weak correlation between authors and files. To avoid multicollinearity problems in our data, we choose to remove change sets from our logistic regression analysis because, due to the enforced processes in RTC, we know that there is exactly one author per change set, and thus there is at least as many change sets as authors per build. Note that weighted congruence and unweighted congruence do not appear in the same model and are thus not subject to multicollinearity problems.

To assess the fit of the logistic regression models, we use the Nagelkerke pseudo-$R^2$ and AIC. $R^2$ shows the proportion of variability explained by the model, and AIC is a measure of how well the model fits the data. Ideally, $R^2$ is high and AIC is low. Our current model contains 19 variables and has an $R^2$ of 0.581 and 0.548 for unweighted and weighted congruence models respectively. We compared our model in Table \ref{tab:models} to a model containing every first-order interaction effect with 27 variables and a model that contains the 7 main effects only (in Table \ref{tab:logr_maineffects}). We found that 19 variables is optimal and that removing further variables lowered the $R^2$ value while raising the AIC.

We observe also that the unweighted congruence model and the weighted congruence model are very similar, with a difference in Nagelkerke $R^2$ of only 0.030.

\begin{table}[t]
\begin{center}
\begin{tabular}{l|r|rr|rr}

             & & \multicolumn{2}{c|}{Unweighted} & \multicolumn{2}{c}{Weighted} \\
Model                  & Variables    & AIC & $R^2$                       & AIC & $R^2$                      \\ \hline
Every interaction  & 27  & 188.6 & 0.595 & 196.7 & 0.559 \\
Main effects only & 7   & 213.2 & 0.269 & 214.2 & 0.263 \\
\textbf{Our model}         & \textbf{19}  & \textbf{175.8} & \textbf{0.581} & \textbf{183.4} & \textbf{0.548} \\
\hline
\end{tabular}
\end{center}
\caption{Model comparison}
\label{tab:models}
\end{table}

\subsection{Effects of Congruence on Build Result}
\label{sec:congruence_effect_build_result}

\begin{table}[t]
\begin{center}
\small
\begin{tabular}{l|r@{\hspace{5pt}}r@{\hspace{-5pt}}r|r@{\hspace{5pt}}r@{\hspace{-5pt}}r}
 & \multicolumn{3}{c|}{Unweighted} & \multicolumn{3}{c}{Weighted} \\\hline
Variable & Coef. & S.E. & \emph{p} & Coef. & S.E. & \emph{p} \\
	\hline
Intercept                   &  -0.5459 &   0.4663 & 0.2417 &    0.3289 &    0.4729 &   0.4867 \\
\textbf{Congruence}              &   \textbf{6.3410} &   \textbf{1.6262} & \textbf{**0.0001} &    3.6699 &    2.3013 &   0.1108 \\
\textbf{Authors}                     &  \textbf{-1.9759} &   \textbf{0.5310} & \textbf{**0.0002} &   \textbf{-2.0176} &    \textbf{0.5802} &   \textbf{**0.0005} \\
\textbf{Files}                       &  \textbf{-1.0734} &   \textbf{0.4561} & \textbf{*0.0186} &   \textbf{-1.1169} &    \textbf{0.5099} &   \textbf{*0.0285} \\
Work~items                   &  -0.1456 &   0.2355 & 0.5363 &   -0.1365 &    0.2343 &   0.5602 \\
\textbf{Build type=I}                      &   \textbf{2.1533} &   \textbf{1.0526} & \textbf{*0.0408} &    1.2777 &    1.0172 &   0.2091 \\
Build type=N                      &   4.6833 & 200.7587 & 0.9814 &    2.7593 &  192.5236 &   0.9886 \\
Build date                   &  -0.6560 &   0.6709 & 0.3282 &   -0.1352 &    0.7133 &   0.8497 \\
\textbf{Congruence * Build type=I}     &  \textbf{-9.2151} &   \textbf{2.5572} & \textbf{**0.0003} &   \textbf{-6.2748} &    \textbf{2.9664} &   \textbf{*0.0344} \\
Congruence * Build type=N     &  -7.7308 &  91.8053 & 0.9329 &   -7.2024 &  188.1811 &   0.9695 \\
Congruence * Build date  &  \textbf{-5.1266} &   \textbf{1.9290} & \textbf{**0.0079} &   \textbf{-5.5670} &    \textbf{1.9760} &   \textbf{**0.0048} \\
Authors $\cdot$ Build type=I            &   1.2688 &   0.7028 & 0.0710 &    1.1852 &    0.7370 &   0.1078 \\
Authors * Build type=N            & 105.4123 & 535.8792 & 0.8441 &  103.0155 &  521.0808 &   0.8433 \\
Authors * Build date         &  -0.6061 &   0.3616 & 0.0937 &   -0.6004 &    0.3576 &   0.0932 \\
Authors * Files             &   0.7663 &   0.4289 & 0.0740 &    0.4979 &    0.5232 &   0.3414 \\
Files * Build type=I              &   1.0920 &   1.1838 & 0.3563 &    1.7042 &    1.4099 &   0.2267 \\
Files * Build type=N              & -37.9274 & 199.2314 & 0.8490 &  -36.5156 &  192.3382 &   0.8494 \\
\textbf{Work~items * Build date}       &   \textbf{0.8040} &   \textbf{0.3003} & \textbf{**0.0074} &    \textbf{0.8909} &    \textbf{0.3466} &   \textbf{*0.0102} \\
\textbf{Build type=I * Build date}          &   \textbf{2.6442} &   \textbf{0.7678} & \textbf{*0.0006} &    \textbf{1.8627} &    \textbf{0.7621} &   \textbf{*0.0145} \\
Build type=N * Build date          &  84.7252 & 344.8129 & 0.8059 &   84.3117 &  341.4988 &   0.8050 \\
	\hline
Model likelihood ratio & 101.92 &  & $R^2=0.581$ & 94.36 &  &	$R^2 = 0.548$ \\
& \multicolumn{3}{c}{191 observations} & \multicolumn{3}{c}{191 observations} \\
\multicolumn{1}{l}{ } & \multicolumn{6}{l}{\scriptsize{Build type is set to continuous}} \\
\multicolumn{1}{l}{\scriptsize{*$p < 0.05$; **$p < 0.01$}} & \multicolumn{6}{l}{\scriptsize{Nagelkerke is used as the pseudo-$R^2$ measure}}
\end{tabular}
\end{center}
\caption{Logistic Regression models predicting build success probability with main and interaction effects}
\label{tab:logr}
\end{table}


\begin{table}[t]
\begin{center}

\begin{tabular}{l|r@{\hspace{5pt}}r@{\hspace{-5pt}}r|r@{\hspace{5pt}}r@{\hspace{-5pt}}r}
 & \multicolumn{3}{c|}{Unweighted} & \multicolumn{3}{c}{Weighted} \\\hline
Variable & Coef. & S.E. & \emph{p} & Coef. & S.E. & \emph{p} \\
	\hline                                                                
	Intercept                &  0.5265 & 0.3040 & 0.0833 &  1.00416 & 0.2754 & 0.0003 \\
	Congruence               &  0.9371 & 0.6807 & 0.1686 & -0.85692 & 0.8544 & 0.3159 \\
	\textbf{Authors}         & \textbf{-0.5702} & \textbf{0.2003} & \textbf{**0.0044} & \textbf{-0.64635} & \textbf{0.2023} & \textbf{**0.0014} \\
	\textbf{Files}           & \textbf{-0.6398} & \textbf{0.2477} & \textbf{**0.0098} & \textbf{-0.70618} & \textbf{0.2571} & \textbf{**0.0060} \\
	Work~items                & -0.1755 & 0.1713 & 0.3055 & -0.13229 & 0.1689 & 0.4335 \\
	Build type=I                   &  0.1693 & 0.4269 & 0.6917 &  0.06128 & 0.4154 & 0.8827 \\
	Build type=N                   &  0.2133 & 0.7791 & 0.7842 &  0.29418 & 0.7811 & 0.7065 \\
	Build date               & -0.1331 & 0.1821 & 0.4649 & -0.11291 & 0.1819 & 0.5349 \\
	\hline
Model likelihood ratio & 40.59 &  & $R^2=0.269$ & 39.52 &  &	$R^2 = 0.263$ \\
& \multicolumn{3}{c}{191 observations} & \multicolumn{3}{c}{191 observations} \\
\multicolumn{1}{l}{ } & \multicolumn{6}{l}{\scriptsize{Build type is set to continuous}} \\
\multicolumn{1}{l}{\scriptsize{*$p < 0.05$; **$p < 0.01$}} & \multicolumn{6}{l}{\scriptsize{Nagelkerke is used as the pseudo-$R^2$ measure}}
\end{tabular}


\end{center}
\caption{Logistic Regression models predicting build success probability with main effects only}
\label{tab:logr_maineffects}
\end{table}

To answer Research Question 1, we perform a logistic regression analysis between the variables of the builds and the build outcome (Table \ref{tab:logr}).

The result of logistic regression indicates that the following effects are significant for both unweighted and weighted congruence models: The congruence~$\times$~build type effect, the congruence~$\times$~build date interaction effect, the number of work~items~$\times$~build date interaction effect, and the build date~$\times$~build type effect. In addition, the number of authors and the number of files are significant main effects, although their coefficients are lower than the interaction effects involving congruence. We also identify unweighted congruence as a significant main effects in the unweighted congruence model.

In the next section we discuss the main effects and interactions effects that involve congruence affecting build probability. We discuss the effects of the non-congruence effects, including the authors, files, work~items~$\times$~date interaction effect and the date~$\times$~nightly~build effect in Section \ref{sec:otherfactors}.

\subsubsection{Effects of interactions involving congruence}
\label{sec:congruenceinteractions}
The type~$\times$~congruence interaction effect, the date~$\times$~congruence interaction, and the type $\times$ date effect are each significant in our model (Table \ref{tab:logr}). We plot in Figures \ref{fig:unweighted_congruence_typeci_age} and \ref{fig:weighted_congruence_typeci_age} the effects of weighted congruence vs. probability of build success at the 10\% date quantile (2008-01-25), at the 25\% date quantile (2008-05-14), the 50\% date quantile (2008-06-07), and the latest build (2008-06-26).


\begin{figure*}
\centering
  \subfloat[ \small{2008-01-25} ]{
    \includegraphics[width=.4\columnwidth]{figures/prob_unweighted_age_typeci_q010}
    \label{subfig:prob_unweighted_age_typeci_q010}
  }
  \subfloat[ \small{2008-05-14} ]{
	\includegraphics[width=.4\columnwidth]{figures/prob_unweighted_age_typeci_q025}
     \label{subfig:prob_unweighted_age_typeci_q025}
  }
  
  \subfloat[ \small{2008-06-07} ]{
	\includegraphics[width=.4\columnwidth]{figures/prob_unweighted_age_typeci_q050}
     \label{subfig:prob_unweighted_age_typeci_q050}
  }
  \subfloat[ \small{2008-06-26} ]{
	\includegraphics[width=.4\columnwidth]{figures/prob_unweighted_age_typeci_q100}
     \label{subfig:prob_unweighted_age_typeci_q100}
  }
  
	\caption{Estimated probability of build success for \emph{unweighted congruence} and \emph{continuous builds C} or \emph{integration builds I}  over time, adjusted to authors $\approx$ -0.156 (17 authors), files $\approx$ -0.352 (131 files), work~items $\approx$ -0.399 (34 work items)}
	\label{fig:unweighted_congruence_typeci_age}
\end{figure*}

\begin{figure*}
\centering
  \subfloat[ \small{2008-01-25} ]{
    \includegraphics[width=.4\columnwidth]{figures/prob_weighted_age_typeci_q010}
    \label{subfig:prob_weighted_age_typeci_q010}
  }
  \subfloat[ \small{2008-05-14} ]{
	\includegraphics[width=.4\columnwidth]{figures/prob_weighted_age_typeci_q025}
     \label{subfig:prob_weighted_age_typeci_q025}
  }
  
  \subfloat[ \small{2008-06-07} ]{
	\includegraphics[width=.4\columnwidth]{figures/prob_weighted_age_typeci_q050}
     \label{subfig:prob_weighted_age_typeci_q050}
  }
  \subfloat[ \small{2008-06-26} ]{
	\includegraphics[width=.4\columnwidth]{figures/prob_weighted_age_typeci_q100}
     \label{subfig:prob_weighted_age_typeci_q100}
  }
  
	\caption{Estimated probability of build success for \emph{weighted congruence} and \emph{continuous builds C} or \emph{integration builds I}  over time, adjusted to authors $\approx$ -0.156 (17 authors), files $\approx$ -0.352 (131 files), work~items $\approx$ -0.399 (34 work items)}
	\label{fig:weighted_congruence_typeci_age}
\end{figure*}

For continuous builds in weighted congruence (Figures \ref{fig:weighted_congruence_typeci_age}, in grey), an increase in congruence correlates to build success probability. The build date as the project ages appears to decrease the probability of build success for high-congruence builds more than low-congruence builds (Figure \ref{subfig:prob_weighted_age_typeci_q100}). Note that, in the unweighted congruence model (Table \ref{tab:logr}) the effect of unweighted congruence on continuous builds is significant, and that increasing congruence also increases the probability that a continuous build will succeed. However, the effect of weighted congruence in continuous builds is not as large as in unweighted congruence, nor is it considered statistically significant.

For integration builds (Figures \ref{fig:weighted_congruence_typeci_age}, in black), an increase in congruence decreases build success, with the exception of the 2008-01-25 build (Figure \ref{subfig:prob_weighted_age_typeci_q010}). In in our 2008-01-25 build, we see that low congruence leads to low build probability, but high congruence has high build probability. As the project ages, this trend reverses and congruence is clearly inversely related with build success probability (Figure \ref{subfig:prob_weighted_age_typeci_q100}).

The effect of congruence is totally opposite for continuous builds and integration builds in both unweighted and weighted congruence. Based on Figure \ref{subfig:prob_unweighted_age_typeci_q100}, increasing unweighted congruence significantly improves the continuous build success rate. However, increasing both types of congruence significantly decreases the integration build success rate.


\subsection{Effect of Gap Size on Build Result}
\label{sec:gapsizeresult}
To answer Research Question 2, we fit a logistic regression model to determine the effect of the mean gap size on the build success probability. The mean gap size appears in Table \ref{tab:summary} and Figure \ref{fig:gapsizes}.

We build logistic regression models based on the model in Table \ref{tab:logr} using the gap size measurement. In the interest of saving space, we report only the odds ratio. We retain every significant interaction from our previous weighted congruence logistic regression in Table \ref{tab:logr}.
We compare two different models: Model G1 contains the gap size with weighted congruence as a variable, and Model G2 contains the gap size without weighted congruence.  We do not use unweighted congruence as it is not possible to calculate gap size with unweighted congruence.

The effect of gap size on build result is significant in both models (Table \ref{tab:oddsratio_gapsize}). This indicates that increasing the gap size significantly increases the odds that an OK build will occur, which is the opposite of what we hypothesized (Figure \ref{fig:prob_gapsize_a}). This means that if the gap size is large, the build success probability increases.

\begin{table}[t]
\begin{center}
\begin{tabular}{l|rr}
  \hline
 & Model G1 & Model G2 \\ 
  \hline
Intercept & 0.95 & 1.32 \\ 
  Authors & 0.43 & 0.60 \\ 
  Files & 0.63 & 0.63 \\ 
  Work~items & 0.75 & 0.85 \\ 
  Build type=I & 4.22 & 1.31 \\ 
  Weighted cong & 8.41 & - \\ 
  Gapsize & 7.71 & 8.71 \\ 
  Build date & 1.81 & 0.59 \\ 
  Authors * Build date & 0.40 & 0.74 \\ 
  Work~items * Build date & 2.75 & 1.83 \\ 
  Build type=I * Build date & 3.54 & 2.52 \\ 
  Build type=I * Weighted cong & 0.01 & - \\ 
  Weighted cong * Build date & 0.00 & - \\ 
   \hline
\end{tabular}
\caption{Odds Ratio for Gapsize Models}
\label{tab:oddsratio_gapsize}
\end{center}
\end{table}


\begin{figure}[t]
	\centering	
	\includegraphics[width=.5\columnwidth]{figures/boxplot_meangapsize}
	\caption{Mean Gap Size per Build}
	\label{fig:gapsizes}
\end{figure}

\begin{figure}[t]
	\centering
	\includegraphics[width=.5\columnwidth]{figures/prob_gapsize_g1}
	\caption{Effect of gap size on build success probability, model G1. }
	\label{fig:prob_gapsize_a}
\end{figure}




\subsection{Social and Technical Factors in RTC Affecting Build Success and Congruence}
\label{sec:otherfactors}
In light of our results, we examine not only the number of work~items~$\times$~date significant interaction found in Section \ref{sec:congruence_effect_build_result}, but different social and technical factors that may affect congruence
and build success probability to find explanations for the interactions between socio-technical congruence and build success probability in RTC.
Specifically, we examine the effect of build date on work items, coordination around fully-congruent builds and
incongruent builds, and the effects of commenting behaviour on builds.

\subsubsection{Other Effects on Build Success}
\label{sec:effectauthors}
\textbf{Authors} For both weighted and unweighted congruence, as the number of authors involved in a build increases, the probability that the build succeeds decreases. The build probability is significantly lowered after more than 15 authors are involved in the build (Figure \ref{subfig:prob_weighted_authors_age_q100}). When over 30 authors are involved in the build, the estimated build success probability falls under 10\%.

\begin{figure}[t]
\centering
\subfloat[ \small{Authors} ] {
\includegraphics[width=.45\columnwidth]{figures/prob_weighted_authors_age_q100}
\label{subfig:prob_weighted_authors_age_q100}
}
\subfloat[ \small{Files} ] {
\includegraphics[width=.45\columnwidth]{figures/prob_weighted_files_age_q100}
\label{subfig:prob_weighted_files_age_q100}
}

\caption{Estimated probability of build success for \emph{authors} and \emph{files}, weighted congruence. Adjusted to work~items $\approx$ -0.399 (34), authors $\approx$ -0.156 (17), files $\approx$ -0.352 (131), w. congruence $\approx$ 0.1446, type = cont, date=2008-06-26}
  \label{fig:weighted_congruence_authors_age}
\end{figure}

\textbf{Files} For both weighted and unweighted congruence, as the number of files involved in a build increases, the probability that the build will succeed decreases (Figure \ref{subfig:prob_weighted_files_age_q100}).

\textbf{Build Date and Work items} The work~items~$\times$~date interaction is significant in both weighted and unweighted congruence. Early in the project, as the number of work items increases, the probability of build success decreases (Figure \ref{subfig:prob_weighted_workitems_age_q010}). As the project ages, this trend reverses and as the number of work items increases, the probability of build success increases as well (Figure \ref{subfig:prob_weighted_workitems_age_q100}). According to the coefficients in Table \ref{tab:logr}, this effect on build success probability is not as strong as the authors main effect or the files main effect.

\begin{figure}[t]
\centering
  \subfloat[ \small{2008-01-25} ]{
    \includegraphics[width=.45\columnwidth]{figures/prob_weighted_workitems_x_age_q010}
    \label{subfig:prob_weighted_workitems_age_q010}
  }
  \subfloat[ \small{2008-06-26} ]{
	\includegraphics[width=.45\columnwidth]{figures/prob_weighted_workitems_x_age_q100}
     \label{subfig:prob_weighted_workitems_age_q100}
  }
  \caption{Estimated probability of build success for \emph{work items} and \emph{date}, weighted congruence. Adjusted to authors $\approx$ -0.156 (17), files $\approx$ -0.352 (131), w. congruence $\approx$ 0.1446, type = cont}
  \label{fig:weighted_congruence_workitems_age}
\end{figure}


\subsubsection{Commenting Behaviour by Change Set Authors}
\label{sec:commenting}
As congruence expects those who contribute technical work to a project to also communicate changes, we decided to examine commenting behaviour of change set contributors.
We examine whether a work item related to a change set has a corresponding comment posted by the change set's author. We also identify if the work item/change set pair is involved in an OK build or an Error build. Note that a work item/change set pair can occur in multiple builds. We consider only comments posted before the build was started. These results are shown in Table \ref{tab:changesets_authors}.
The build result rates does not appear to be affected by whether the change set contributor commented: 43\% of the builds resulted in error when the contributor commented, and 41\% of builds resulted in error when the contributor did not comment. A $\chi^2$ test on this table does not show a significant difference between the factors at the 0.05 threshold ($\chi^2 = 3.217$, df = 1, {p=0.073}).
Overall, in 76\% of the change set/work item pairs, the change set contributor also posted a comment in the associated work item.
\begin{table}[t]
\centering
\begin{tabular}{lrrr}
Result & \parbox{0.715in}{\raggedright Change sets w/o comment by contributor\vspace{1pt}} & \parbox{0.715in}{\raggedright Change sets w/ comment by contributor\vspace{1pt}} & Total \\\hline 
OK		& 1278 (14\%) 	& 3956 (43\%) 	& 5234 (57\%) 	\\
ERR		& 908 (10\%) 	& 3076 (33\%)	& 3984 (43\%)	\\\hline
Total 	& 2186 (24\%) 	& 7032 (76\%) 	& 9218 (100\%)	\\
\end{tabular}
\caption{Number of change sets in which a contributor commented in the corresponding work item}
\label{tab:changesets_authors}
\end{table}

\subsubsection{Examining Extreme Congruence Values}
\label{sec:extremecongruence}
We are interested in the differences between high-congruence builds and low-congruence builds.
We further this investigation by looking at builds that have extreme values of congruence: zero, where absolutely no coordination needs are satisfied with communication, and one, where every coordination need is satisfied with communication.
We chose to investigate the extreme cases to see if there were differences in the way people coordinated in fully-congruent builds, and in incongruent builds.
Table \ref{tab:congruence_extremes} shows the number of OK and error builds that occurred when congruence was equal to one, and equal to zero. The weighted builds with full congruence are a subset of the unweighted builds with full congruence.


\begin{table}[t]
\centering
\begin{tabular}{ll|rr}
& & \multicolumn{2}{c}{Congruence} \\\hline
&  & 1 & 0 \\\hline 
\multirow{2}{*}{Unweighted} & OK & 26 & 30 \\
                            & ERR & 2 & 2 \\\hline
\multirow{2}{*}{Weighted} & OK & 6 & 30 \\
                         & ERR & 1 & 2 \\
\end{tabular}
\caption{Number of Builds with Congruence Values 0 and 1}
\label{tab:congruence_extremes}
\end{table}

To determine if the presence of commenting affected the builds, we examined the number of comments on work item--change set pairs in builds with extreme unweighted congruence values. Our results are shown in Table \ref{tab:changeset_commenters}. Build success probabilities improve with respect to builds that have no comments, though work items with no comments are in the minority.

Of note is the high number of comments on work items that have zero congruence. This indicates that individuals who have no technical relationship to the work item are commenting on the work item.

\begin{table}[t]
\centering
\begin{tabular}{ll|rr|rr}
& & \multicolumn{2}{c|}{Num. of Pairs} & \multicolumn{2}{c}{Success rate} \\
Congruence &                                & 1     & 0   & 1 & 0 \\\hline 
\multirow{2}{*}{No comments} 	& OK 	  & 42   & 143  &  \multirow{2}{*}{49\%} & \multirow{2}{*}{69\%}  \\
                            	& Error   & 43    & 64   &  & \\\hline
\multirow{2}{*}{Comments} 	& OK 	  & 610  & 445  & \multirow{2}{*}{68\%} & \multirow{2}{*}{69\%}  \\
                         	& Error   & 290   & 199  &  & \\\hline
\multirow{2}{*}{Total} 		& OK		  & 652 & 588 &     \multirow{2}{*}{66\%} & \multirow{2}{*}{69\%}   \\
                       		& Error   & 333  & 263 & &\\
\end{tabular}
\caption{Number of work items-change set pairs with comments and build success probabilities for congruence 0 and 1}
\label{tab:changeset_commenters}
\end{table}

We manually inspected the work items with extreme amounts of congruence, reading the comments for any differences in the content discussed. Unfortunately, there were no obvious qualities between comments made in a build with a congruence of zero, and comments made in a build with a congruence of one. In both builds, individuals discussed technical implementation details, provided updates to colleagues, or requested assistance from colleagues. We are unable to discover root causes of failure without a deeper examination of the technical changes and more knowledge of the RTC context.


\section{TODO: Discussion}
\label{sec:discussion}
The concepts illustrated in Conway's Law, as well as previous empirical work on socio-technical congruence lead us to expect that team members must coordinate according to coordination needs suggested by technical dependencies in order to build software effectively.
In this case study, we applied socio-technical congruence to study coordination and its relationship to build success probability in RTC. We applied a modified weighted congruence measurement to study also how the size of a coordination gap affects build success probability, and investigated what social and technical factors in RTC affect congruence and builds.

Overall, we found that the average congruence across builds was very low---only 20--30\% of the coordination needs in the project were fulfilled with actual coordination. Even in the cases where there is zero congruence, the build result was an OK build in over 90\% of the observed cases.

Our first research question asked:
\textbf{Does socio-technical congruence have an effect on build success probability in RTC?}
We found that there was an interaction effect involving congruence and build type on build success probabilities (Section \ref{sec:congruenceinteractions}). For continuous builds, increasing congruence improves the chance of build success in continuous builds and can actually decrease build success probability in integration builds (Figures \ref{fig:weighted_congruence_typeci_age}). High unweighted congruence significantly improves continuous build success probability, and both unweighted and weighted congruence significantly reduce integration build success probability.

Our second research question asked:
\textbf{Does gap size have an effect on build success probability
in RTC?}
The gap size is a representation of whether enough coordination
occurred to fulfill multiple coordination needs. If two developers have multiple dependencies on each other, one would expect them to
coordinate more often as well.
We hypothesized that a small mean gap size would increase the probability of successful builds and that a large mean gap size would decrease the probability of a successful build. Instead, we found that as the mean gap size increases, the build success probability also increases (Figure \ref{fig:prob_gapsize_a}).

Below we discuss the reasons for these observed results based on our knowledge of RTC.

\subsection{Strong Awareness Helps Coordination}
The overall congruence for the majority of builds is low: over 75\% of
builds have a congruence of less than 0.25 (Section \ref{sec:congruence_effect_build_result}).
Despite low congruence, the RTC team is able to successfully build its software in many situations.
The fact that the change set author comments on a work item related to the change set does not appear to affect build results either (Section \ref{sec:commenting}), suggesting that changes do not need to be explicitly communicated for every build.


When we examined extreme congruence values, we observed 85\% build success probability when weighted congruence is 1 and 93\% build success when weighted congruence is 0 (Section \ref{sec:extremecongruence}).
If socio-technical congruence is a measure of coordination quality in software, and builds rely on coordination quality to be successful, then there must be reasons why builds can succeed even when the congruence is zero.

First, because RTC is a highly-distributed project, the product under development uses a modular design \cite{maccormack2006} and thus is affected less by dependencies. Second, team members in RTC do not conduct all of their coordination through \emph{explicit communication} even though work item inspection and discussion with developers indicate that the RTC corporate culture focuses on the work item as their base for communication. Rather, they use the \emph{shared workspace} that incorporates cues from the environment and from peers in order to address technical issues. Both of these effects may contribute to congruence being lower than expected.

\subsubsection{RTC supports Explicit Communication}
The RTC team members use the RTC environment extensively to communicate with each other. We were informed that RTC team members rarely use private email, and our inspection of the mailing list reveals that its primary purpose is for announcements such as server outages rather than for discussing technical work.

This leaves the RTC work item comment system and instant messaging as methods for communication, as well as the phone and internal face-to-face meetings.
We learned that while face-to-face interaction is efficient for solving local issues, it does not benefit remote teams, and the RTC team as a whole encourages every team member to record face-to-face discussions as comments for the purpose of archiving and sharing information.

However, explicit coordination has a cost. There is evidence that involving too many authors in the same build also reduces the build success when using a weighted congruence conceptualization (Figure \ref{subfig:prob_weighted_authors_age_q100}); the effect for unweighted congruence is similar. The overhead required to coordinate many people may interfere with the ability of the team to build the project successfully, suggesting that there is a limit before a developer is overloaded with information.

\subsubsection{RTC is a Shared Workspace}
The RTC client software helps a developer acquire and maintain \emph{environmental awareness} of what is going on in the project by providing access to a shared workspace. Much of the work is centred around the RTC technical entities, which include plans, source code, work items, and comments.
RTC's awareness mechanisms feature a developer-centred dashboard that reports changes to the workspace, built-in traceability, user notifications, regularly-generated reports, and an optional web browser interface. For example, when a change set is created, it is attached to a work item, thus ensuring that people who are involved with the work item receive notification of this change set. These automatic notifications cut down the amount of explicit communication and allow people to coordinate implicitly.

Coordinating using the workspace is well-known in the computer-supported cooperative work domain \cite{schmidt1996}. Open-source developers, in particular, coordinate around source code~\cite{bolici:stc:2009} and mailing lists \cite{gutwin2004:awareness,mockus2002:opensource} because there is little opportunity for face-to-face interaction. RTC shares many characteristics with open-source development, such as a distributed team and a transparent development process.

In light of these results, we believe that, using our conceptualization, the RTC team requires a congruence of only 0.2--0.3 for their tasks to be completed.
Much of the need for explicit, point-to-point communication is mitigated by implicit communication and the use of the workspace to coordinate.
We expect that the remaining congruence is covered through the RTC workspace, and through face-to-face communication, instant messenger, and phone communication. Though our congruence value appears low for the RTC team, the coordination in reality may be higher. Future studies should keep in mind that congruence may be lower than expected because of conceptualizations that cannot include every type of coordination in a project.

\subsection{Coordination and Geographic Distribution}
As RTC is a distributed team, geographic distribution has an effect on team performance, though the RTC environment helps mitigate some of these effects \cite{Nguyen:2008Distance}.

We learned from the RTC project that continuous and nightly builds should involve mainly a co-located team, and that integration builds involve multiple components from RTC teams in different locations. Our results suggest that congruence best benefits builds that occur within co-located teams; however, the design of our study does not allow us to draw a firm conclusion about the influence of both co-location and congruence on build success probability.

It appears that involving too many individuals when coordinating the activities of various teams may harm build success due to information overload~\cite{damian:icgse:2007}, especially when the team members are distributed. To negate this effect, development leaders and build managers that have an overall view of the project are suited to coordinate teams to ensure build success \cite{hinds:cscw:2006}.

\subsection{Communication Between Individuals Occurs When Problems Arise}
\label{sec:communicating_problems}
Our results indicate that even when congruence gaps are bridged, there is a high probability that a build still fails.

We have observed that, due to awareness through RTC, the RTC team is able to react to situations with multiple technical dependencies by communicating quickly, a trait that has been previously observed among open-source developers \cite{mockus2002:opensource}. Contributors are likely to comment on their own change sets (Section \ref{sec:commenting}).

The RTC team is aware of builds that require high coordination, and are able to address the situation by coordinating with comments. If a work item was particularly complex during development, a developer will post comments on a work item requesting expertise and informing others about unanticipated problems.
This amount of written communication may not occur in an OK build simply because the level of coordination is not necessary; in essence, not every technical dependency requires explicit coordination to bridge that gap.
There is also a possibility that developers coordinate on difficult builds using methods that are not captured by our conceptualizations such as phone or face-to-face. More study of how developers coordinate under ``problematic situations'' is warranted.


\subsection{Project Maturity and Build Success}
We found that early builds exhibited a different type of relationship between congruence and build success probability than later builds (Section \ref{sec:congruenceinteractions}). Over the course of the study, we observed 13 internal milestones; the last milestone in our observed builds was a public beta release for end users.

Build success probability decreased significantly over time for continuous builds and stayed roughly the same for integration builds (Figures \ref{fig:weighted_congruence_typeci_age}).
However, the early builds in the project behaved contrary to later builds in the project (Figure \ref{subfig:prob_weighted_age_typeci_q010} and \ref{subfig:prob_weighted_age_typeci_q010}). The RTC software early in its lifetime is in a state of change. Integration builds are not a priority, and features are being added to the project. This means that dependencies are changing rapidly, as well as the expertise among team members, making it difficult to solidify coordination needs.

In addition to interactions between congruence and type, and congruence and date, we observed a significant interaction effect between build date and work items.
We found that early in the project (Figure \ref{subfig:prob_weighted_workitems_age_q010}), builds with large numbers of work items have a high probability of failing, but late in the project (Figure \ref{subfig:prob_weighted_workitems_age_q100}), these builds succeed. Because the latest release was focused on a public release, a build linked to numerous work items may indicate that a bug is highly problematic or a feature is highly desired, and therefore received more attention. This is similar to the effect discussed with gap size (Section \ref{sec:communicating_problems}), where an error build requires more coordination from involved developers.


\subsection{Improvements to Socio-technical Congruence}
\label{sec:improvements}
Based on these results, we discuss our conceptualizations of congruence, and how we can improve socio-technical congruence as an approach to measuring coordination. This paper takes a step in the direction of exploring the situations of applicability that socio-technical congruence has to software projects. Our study is limited to digital, comment-based communication, but indicates the usefulness of socio-technical congruence in highlighting the relationship between communication, technical dependencies, and work outcomes.

We presented a weighted congruence measure which provides measurements such as gap sizes and relationship strengths that were not available by using unweighted congruence. Although the weighted congruence measure yielded similar results to the unweighted congruence measure, the weighted congruence model appeared to lower the threshold of congruence by smoothing out the index values into a more balanced distribution compared to unweighted congruence (compare Figures \ref{subfig:hist_nonweighted} and \ref{subfig:hist_weighted}).
This led to the unweighted congruence model having a significant main effect on continuous build success, whereas the weighted congruence model did not have such an effect.
This shows that weighted congruence is a more conservative
measure than unweighted congruence. Depending on the objective of the
analysis, the unweighted congruence may represent an upper range of
potential congruence in a project, whereas the weighted congruence
tends to be less likely to report perfect congruence and may represent an average scenario.

However our conceptualization of who should be related to a work item is not complete and can be improved.
Many roles in the project are important, but do not have explicit technical dependencies.
For example, we know that RTC has a build coordinator that handles build issues; this person is not assigned to any change sets.
A person who is not identified as being part of the coordination needs network, but appears in the actual coordination network is called an \emph{emergent person}\cite{damian2007:collaboration}.
We identified people who were coordinating with others even though they were not in the coordination needs matrix.
This was illustrated most clearly by the presence of comments on a build that has a congruence index of 0 (Section \ref{sec:extremecongruence}).
Current congruence conceptualizations ignore people that do not have coordination needs but communicate in the actual coordination network.
Thus one improvement is to incorporate people who are involved in actual coordination, but not in technical dependencies, into the congruence calculation. 

A further improvement to socio-technical congruence measures is to improve the
conceptualization of socio-technical congruence to incorporate indirect
communication, especially the information that a developer receives from the
environment. If environment information is transmitted through the software, then fine-grained logging will capture these automatic notifications and can be incorporated into congruence.

Another improvement would be modelling transitive communication because information often travels to individuals through other individuals. For example, an experienced development leader may receive information from multiple teams and forward information to appropriate individuals. Two individuals with a dependency may be able to satisfy their dependencies by communicating through this development leader.

\subsection{Threats to Validity}
\label{sec:threats}
Socio-technical congruence can be difficult to compare between studies. Conceptualizations, such as technical dependencies and actual coordination, vary from project to project. Some project-specific conceptualizations we used are the build as a measure of success, the fact that only files that are touched by more than one individual qualified as having dependencies on each other, and the work item comments connecting people in a clique.
Because of the context-sensitive nature of socio-technical congruence, especially with respect to the construction of communication and dependencies, it is difficult to apply socio-technical congruence as a benchmark for coordination. Having an understanding of the context of the project is extremely important when interpreting results obtained from socio-technical congruence calculations.

Our coordination needs are likely overestimated due to the modular nature of RTC.
As we are studying a distributed project that follows a transparent development process, RTC uses a modular design \cite{maccormack2006} and a change in a file in a change set may not necessarily be dependent on other changes within the same file. 
We observed evidence in our study that the dependencies among change sets as well as the attached work items may not be as strong as we have originally believed.

Our conceptualization of actual coordination underestimates the amount of communication that truly occurs in the project. 
We relied on repository data in RTC and were unable to conceptualize forms of communication such as instant messenger, phone calls, and face-to-face interactions.
Due to geographical distance and time zone differences, the RTC team's primary mode of collaboration is the work item comment system, but we made a number of assumptions about commenting behaviour.

First, we assume that everyone involved in the work item reads every comment. Second, we do not take into consideration any additional coordination that may occur from a silent onlooker reading the comments. We believe intuitively that the first effect is greater than the second.
This may help explain part of the effect of the unintuitive gap size result; rather than the gap being actually large in reality, it is large in our conceptualization because actual coordination outside of commenting is not recorded.

Another threat to validity is that our data does not cover every build executed in the lifetime of RTC. RTC does not keep a full archive of build results, and as a consequence, we do not have a full population from which to draw data from. The threats are particularly high for early data points. The large confidence intervals in some of the builds, namely nightly builds, reflect this lack of data, thus we hesitate to draw conclusions based on early builds and nightly builds.

Finally, this study is a single case study and the results are not generalizable, nor can they be directly compared to existing studies due to the differences in the projects under examination. However, we believe that this study advances the theoretical and the empirical examination of socio-technical congruence, and raises a number of questions that are worthwhile for future study.


\section{Conclusion}
\label{sec:conclusion}
We end this chapter by bringing it back to the initial research question we set out to answer:
\begin{description}
  \item[RQ 1.2:] Does Socio-Technical Networks influence build success?
\end{description}

We conducted two investigations: (1) the investigation the influence of the socio-technical congruence index on build success and (2) the investigation of gaps as within the socio-technical networks.
Both avenues of investigations showed that they expose an influence on build success even in the presence of other measures of build size.

These findings, especially that gaps within socio-technical networks influence build success opens the door to formulating an approach on how to leverage the concept of socio-technical congruence to improve the communication among software developers.
Thus in the next chapter we will detail an approach that we propose to improve developer communication using the concept of socio-technical congruence.
